<?xml version='1.0'?>
<CodeNarc url='http://www.codenarc.org' version='1.4'><Report timestamp='Mar 13, 2020 12:26:56 PM'/><Project title=''><SourceDirectory>src</SourceDirectory></Project><PackageSummary totalFiles='1' filesWithViolations='1' priority1='0' priority2='1' priority3='3'></PackageSummary><Package path='main' totalFiles='1' filesWithViolations='1' priority1='0' priority2='1' priority3='3'></Package><Package path='main/groovy' totalFiles='1' filesWithViolations='1' priority1='0' priority2='1' priority3='3'><File name='Hello.groovy'><Violation ruleName='CompileStatic' priority='2' lineNumber='1'><SourceLine><![CDATA[class Hello {]]></SourceLine><Message><![CDATA[Class should be marked with one of @GrailsCompileStatic, @CompileStatic or @CompileDynamic]]></Message></Violation><Violation ruleName='ClassStartsWithBlankLine' priority='3' lineNumber='2'><SourceLine><![CDATA[    void sayHello() {]]></SourceLine><Message><![CDATA[Class does not start with a blank line after the opening brace]]></Message></Violation><Violation ruleName='UnnecessaryGString' priority='3' lineNumber='3'><SourceLine><![CDATA[println "Hello world"]]></SourceLine><Message><![CDATA[The String 'Hello world' can be wrapped in single quotes instead of double quotes]]></Message></Violation><Violation ruleName='FileEndsWithoutNewline' priority='3' lineNumber='5'><SourceLine><![CDATA[}]]></SourceLine><Message><![CDATA[File Hello.groovy does not end with a newline]]></Message></Violation></File></Package><Rules><Rule name='AbstractClassName'><Description><![CDATA[Verifies that the name of an abstract class matches a regular expression specified in the regex property. If that property is null or empty, then this rule is not applied (i.e., it does nothing). It defaults to null, so this rule must be explicitly configured to be active. This rule ignores interfaces.]]></Description></Rule><Rule name='AbstractClassWithPublicConstructor'><Description><![CDATA[Checks for abstract classes that define a public constructor, which is useless and confusing.]]></Description></Rule><Rule name='AbstractClassWithoutAbstractMethod'><Description><![CDATA[The abstract class does not contain any abstract methods. An abstract class suggests an incomplete implementation, which is to be completed by subclasses implementing the abstract methods. If the class is intended to be used as a base class only (not to be instantiated direcly) a protected constructor can be provided prevent direct instantiation.]]></Description></Rule><Rule name='AddEmptyString'><Description><![CDATA[Finds empty string literals which are being added. This is an inefficient way to convert any type to a String.]]></Description></Rule><Rule name='AssertWithinFinallyBlock'><Description><![CDATA[Checks for assert statements within a finally block. An assert can throw an exception, hiding the original exception, if there is one.]]></Description></Rule><Rule name='AssignmentInConditional'><Description><![CDATA[An assignment operator (=) was used in a conditional test. This is usually a typo, and the comparison operator (==) was intended.]]></Description></Rule><Rule name='AssignmentToStaticFieldFromInstanceMethod'><Description><![CDATA[Checks for assignment to a static field from an instance method.]]></Description></Rule><Rule name='BigDecimalInstantiation'><Description><![CDATA[Checks for calls to the BigDecimal constructors that take a double parameter, which may result in an unexpected BigDecimal value.]]></Description></Rule><Rule name='BitwiseOperatorInConditional'><Description><![CDATA[Checks for bitwise operations in conditionals, if you need to do a bitwise operation then it is best practice to extract a temp variable.]]></Description></Rule><Rule name='BlankLineBeforePackage'><Description><![CDATA[Makes sure there are no blank lines before the package declaration of a source code file.]]></Description></Rule><Rule name='BlockEndsWithBlankLine'><Description><![CDATA[Checks that code blocks such as method bodies, closures and control structure bodies do not end with an empty line.]]></Description></Rule><Rule name='BlockStartsWithBlankLine'><Description><![CDATA[Checks that code blocks such as method bodies, closures and control structure bodies do not start with an empty line.]]></Description></Rule><Rule name='BooleanGetBoolean'><Description><![CDATA[This rule catches usages of java.lang.Boolean.getBoolean(String) which reads a boolean from the System properties. It is often mistakenly used to attempt to read user input or parse a String into a boolean. It is a poor piece of API to use; replace it with System.properties['prop'].]]></Description></Rule><Rule name='BooleanMethodReturnsNull'><Description><![CDATA[Method with Boolean return type returns explicit null. A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.]]></Description></Rule><Rule name='BracesForClass'><Description><![CDATA[Checks the location of the opening brace ({) for classes. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></Description></Rule><Rule name='BracesForForLoop'><Description><![CDATA[Checks the location of the opening brace ({) for for loops. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></Description></Rule><Rule name='BracesForIfElse'><Description><![CDATA[Checks the location of the opening brace ({) for if statements. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></Description></Rule><Rule name='BracesForMethod'><Description><![CDATA[Checks the location of the opening brace ({) for constructors and methods. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></Description></Rule><Rule name='BracesForTryCatchFinally'><Description><![CDATA[Checks the location of the opening brace ({) for try statements. By default, requires them on the line, but the sameLine property can be set to false to override this.]]></Description></Rule><Rule name='BrokenNullCheck'><Description><![CDATA[Looks for faulty checks for null that can cause a NullPointerException.]]></Description></Rule><Rule name='BrokenOddnessCheck'><Description><![CDATA[The code uses x % 2 == 1 to check to see if a value is odd, but this won't work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.]]></Description></Rule><Rule name='BuilderMethodWithSideEffects'><Description><![CDATA[A builder method is defined as one that creates objects. As such, they should never be of void return type. If a method is named build, create, or make, then it should always return a value.]]></Description></Rule><Rule name='CatchArrayIndexOutOfBoundsException'><Description><![CDATA[Check the size of the array before accessing an array element rather than catching ArrayIndexOutOfBoundsException.]]></Description></Rule><Rule name='CatchError'><Description><![CDATA[Catching Error is dangerous; it can catch exceptions such as ThreadDeath and OutOfMemoryError.]]></Description></Rule><Rule name='CatchException'><Description><![CDATA[Catching Exception is often too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.]]></Description></Rule><Rule name='CatchIllegalMonitorStateException'><Description><![CDATA[Dubious catching of IllegalMonitorStateException. IllegalMonitorStateException is generally only thrown in case of a design flaw in your code (calling wait or notify on an object you do not hold a lock on).]]></Description></Rule><Rule name='CatchIndexOutOfBoundsException'><Description><![CDATA[Check that an index is valid before accessing an indexed element rather than catching IndexOutOfBoundsException.]]></Description></Rule><Rule name='CatchNullPointerException'><Description><![CDATA[Catching NullPointerException is never appropriate. It should be avoided in the first place with proper null checking, and it can mask underlying errors.]]></Description></Rule><Rule name='CatchRuntimeException'><Description><![CDATA[Catching RuntimeException is often too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.]]></Description></Rule><Rule name='CatchThrowable'><Description><![CDATA[Catching Throwable is dangerous; it can catch exceptions such as ThreadDeath and OutOfMemoryError.]]></Description></Rule><Rule name='ClassEndsWithBlankLine'><Description><![CDATA[Check whether the class ends with a blank line.By default, it enforces that there must be a blank line before the closing class brace, except if the class is empty and is written in a single line. A blank line is defined as any line that does not contain any visible characters.]]></Description></Rule><Rule name='ClassForName'><Description><![CDATA[Using Class.forName(...) is a common way to add dynamic behavior to a system. However, using this method can cause resource leaks because the classes can be pinned in memory for long periods of time.]]></Description></Rule><Rule name='ClassName'><Description><![CDATA[Verifies that the name of a class matches a regular expression. By default it checks that the class name starts with an uppercase letter and is followed by zero or more word characters (letters, numbers or underscores). The regex property specifies the regular expression used to validate the class name.]]></Description></Rule><Rule name='ClassNameSameAsFilename'><Description><![CDATA[Reports files containing only one top level class / enum / interface which is named differently than the file.]]></Description></Rule><Rule name='ClassNameSameAsSuperclass'><Description><![CDATA[Checks for any class that has an identical name to its superclass, other than the package. This can be very confusing.]]></Description></Rule><Rule name='ClassStartsWithBlankLine'><Description><![CDATA[Check whether the class starts with a blank line. By default, it enforces that there must be a blank line after the opening class brace, except if the class is empty and is written in a single line. A blank line is defined as any line that does not contain any visible characters.]]></Description></Rule><Rule name='CloneableWithoutClone'><Description><![CDATA[A class that implements java.lang.Cloneable should define a clone() method.]]></Description></Rule><Rule name='CloseWithoutCloseable'><Description><![CDATA[If a class defines a "void close()" then that class should implement java.io.Closeable or java.lang.AutoCloseable.]]></Description></Rule><Rule name='ClosureStatementOnOpeningLineOfMultipleLineClosure'><Description><![CDATA[Checks for closure logic on first line (after -&gt;) for a multi-line closure.]]></Description></Rule><Rule name='CompareToWithoutComparable'><Description><![CDATA[If you implement a compareTo method then you should also implement the Comparable interface. If you don't then you could possibly get an exception if the Groovy == operator is invoked on your object. This is an issue fixed in Groovy 1.8 but present in previous versions.]]></Description></Rule><Rule name='ComparisonOfTwoConstants'><Description><![CDATA[Checks for expressions where a comparison operator or equals() or compareTo() is used to compare two constants to each other or two literals that contain only constant values, e.g.: 23 == 67, Boolean.FALSE != false, 0.17 &lt;= 0.99, "abc" &gt; "ddd", [a:1] &lt;=&gt; [a:2], [1,2].equals([3,4]) or [a:false, b:true].compareTo(['a':34.5, b:Boolean.TRUE], where x is a variable.]]></Description></Rule><Rule name='ComparisonWithSelf'><Description><![CDATA[Checks for expressions where a comparison operator or equals() or compareTo() is used to compare a variable to itself, e.g.: x == x, x != x, x &lt;=&gt; x, x &lt; x, x &gt;= x, x.equals(x) or x.compareTo(x), where x is a variable.]]></Description></Rule><Rule name='CompileStatic'><Description><![CDATA[Check that classes are explicitely annotated with either @GrailsCompileStatic, @CompileStatic or @CompileDynamic]]></Description></Rule><Rule name='ConfusingClassNamedException'><Description><![CDATA[This class is not derived from another exception, but ends with 'Exception'. This will be confusing to users of this class.]]></Description></Rule><Rule name='ConfusingMethodName'><Description><![CDATA[Checks for confusing method names. The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.]]></Description></Rule><Rule name='ConfusingTernary'><Description><![CDATA[In a ternary expression avoid negation in the test. For example, rephrase: "(x != y) ? diff : same" as: "(x == y) ? same : diff". Consistent use of this rule makes the code easier to read. Also, this resolves trivial ordering problems, such as "does the error case go first?" or "does the common case go first?".]]></Description></Rule><Rule name='ConsecutiveBlankLines'><Description><![CDATA[Makes sure there are no consecutive lines that are either blank or whitespace only.]]></Description></Rule><Rule name='ConsecutiveLiteralAppends'><Description><![CDATA[Violations occur when method calls to append(Object) are chained together with literals as parameters. The chained calls can be joined into one invocation.]]></Description></Rule><Rule name='ConsecutiveStringConcatenation'><Description><![CDATA[Catches concatenation of two string literals on the same line. These can safely by joined.]]></Description></Rule><Rule name='ConstantAssertExpression'><Description><![CDATA[Checks for assert statements where the assert boolean condition expression is a constant or literal value.]]></Description></Rule><Rule name='ConstantIfExpression'><Description><![CDATA[Checks for if statements with a constant value for the if expression, such as true, false, null, or a literal constant value.]]></Description></Rule><Rule name='ConstantTernaryExpression'><Description><![CDATA[Checks for ternary expressions with a constant value for the boolean expression, such as true, false, null, or a literal constant value.]]></Description></Rule><Rule name='ConstantsOnlyInterface'><Description><![CDATA[An interface should be used only to model a behaviour of a class: using an interface as a container of constants is a poor usage pattern.]]></Description></Rule><Rule name='CouldBeElvis'><Description><![CDATA[Catch an if block that could be written as an elvis expression.]]></Description></Rule><Rule name='CouldBeSwitchStatement'><Description><![CDATA[Checks for multiple if statements that could be converted to a switch]]></Description></Rule><Rule name='DeadCode'><Description><![CDATA[Dead code appears after a return statement or an exception is thrown. If code appears after one of these statements then it will never be executed and can be safely deleted.]]></Description></Rule><Rule name='DoubleNegative'><Description><![CDATA[There is no point in using a double negative, it is always positive. For instance !!x can always be simplified to x. And !(!x) can as well.]]></Description></Rule><Rule name='DuplicateCaseStatement'><Description><![CDATA[Check for duplicate case statements in a switch block, such as two equal integers or strings.]]></Description></Rule><Rule name='DuplicateImport'><Description><![CDATA[Duplicate import statements are unnecessary.]]></Description></Rule><Rule name='DuplicateListLiteral'><Description><![CDATA[Code containing duplicate List literals can usually be improved by declaring the List as a constant field.]]></Description></Rule><Rule name='DuplicateMapKey'><Description><![CDATA[A map literal is created with duplicated key. The map entry will be overwritten.]]></Description></Rule><Rule name='DuplicateMapLiteral'><Description><![CDATA[Code containing duplicate Map literals can usually be improved by declaring the Map as a constant field.]]></Description></Rule><Rule name='DuplicateNumberLiteral'><Description><![CDATA[Code containing duplicate number literals can usually be improved by declaring the number as a constant field.  The ignoreNumbers property (0,1) can optionally specify a comma-separated list of numbers to ignore.]]></Description></Rule><Rule name='DuplicateSetValue'><Description><![CDATA[A Set literal is created with duplicate constant value. A set cannot contain two elements with the same value.]]></Description></Rule><Rule name='DuplicateStringLiteral'><Description><![CDATA[Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The ignoreStrings property () can optionally specify a comma-separated list of Strings to ignore.]]></Description></Rule><Rule name='ElseBlockBraces'><Description><![CDATA[Use braces for else blocks, even for a single statement. By default, braces are not required for an else if it is followed immediately by an if. Set the bracesRequiredForElseIf property to true to require braces is that situation as well.]]></Description></Rule><Rule name='EmptyCatchBlock'><Description><![CDATA[In most cases, exceptions should not be caught and ignored (swallowed).]]></Description></Rule><Rule name='EmptyClass'><Description><![CDATA[Reports classes without methods, fields or properties. Why would you need a class like this?]]></Description></Rule><Rule name='EmptyElseBlock'><Description><![CDATA[Empty else blocks are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyFinallyBlock'><Description><![CDATA[Empty finally blocks are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyForStatement'><Description><![CDATA[Empty for statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyIfStatement'><Description><![CDATA[Empty if statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyInstanceInitializer'><Description><![CDATA[An empty class instance initializer was found. It is safe to remove it.]]></Description></Rule><Rule name='EmptyMethod'><Description><![CDATA[A method was found without an implementation. If the method is overriding or implementing a parent method, then mark it with the @Override annotation.]]></Description></Rule><Rule name='EmptyMethodInAbstractClass'><Description><![CDATA[An empty method in an abstract class should be abstract instead, as developer may rely on this empty implementation rather than code the appropriate one.]]></Description></Rule><Rule name='EmptyStaticInitializer'><Description><![CDATA[An empty static initializer was found. It is safe to remove it.]]></Description></Rule><Rule name='EmptySwitchStatement'><Description><![CDATA[Empty switch statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptySynchronizedStatement'><Description><![CDATA[Empty synchronized statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyTryBlock'><Description><![CDATA[Empty try blocks are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyWhileStatement'><Description><![CDATA[Empty while statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EqualsAndHashCode'><Description><![CDATA[If either the equals(Object) or the hashCode() methods are overridden within a class, then both must be overridden.]]></Description></Rule><Rule name='EqualsOverloaded'><Description><![CDATA[The class has an equals method, but the parameter of the method is not of type Object. It is not overriding equals but instead overloading it.]]></Description></Rule><Rule name='ExceptionExtendsError'><Description><![CDATA[Errors are system exceptions. Do not extend them.]]></Description></Rule><Rule name='ExceptionExtendsThrowable'><Description><![CDATA[Checks for classes that extend Throwable. Custom exception classes should subclass Exception or one of its descendants.]]></Description></Rule><Rule name='ExceptionNotThrown'><Description><![CDATA[Checks for an exception constructor call without a throw as the last statement within a catch block.]]></Description></Rule><Rule name='ExplicitGarbageCollection'><Description><![CDATA[Calls to System.gc(), Runtime.getRuntime().gc(), and System.runFinalization() are not advised. Code should have the same behavior whether the garbage collection is disabled using the option -Xdisableexplicitgc or not. Moreover, "modern" jvms do a very good job handling garbage collections. If memory usage issues unrelated to memory leaks develop within an application, it should be dealt with JVM options rather than within the code itself.]]></Description></Rule><Rule name='FactoryMethodName'><Description><![CDATA[A factory method is a method that creates objects, and they are typically named either buildFoo(), makeFoo(), or createFoo(). This rule enforces that only one naming convention is used. It defaults to makeFoo(), but that can be changed using the property 'regex'.]]></Description></Rule><Rule name='FieldName'><Description><![CDATA[Verifies that the name of each field matches a regular expression. By default it checks that non-'final' field names start with a lowercase letter and contains only letters or numbers, and 'final' field names start with an uppercase letter and contain only uppercase letters, numbers and underscores. The regex property specifies the default regular expression used to validate field names. The finalRegex property specifies the regular expression to validate 'final' field names. The staticRegex property specifies the regular expression to validate 'static' field names. The staticFinalRegex property specifies the regular expression to validate 'static final' field names.  The ignoreFieldNames property (serialVersionUID) can specify field names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></Description></Rule><Rule name='FieldTypeRequired'><Description><![CDATA[Checks that field types are explicitly specified (and not using def).]]></Description></Rule><Rule name='FileEndsWithoutNewline'><Description><![CDATA[Makes sure the source code file ends with a newline character.]]></Description></Rule><Rule name='FinalClassWithProtectedMember'><Description><![CDATA[This rule finds classes marked final that contain protected methods. If a class is final then it may not be subclassed, and there is therefore no point in having a method with protected visibility. Either the class should not be final or the method should be private or protected.]]></Description></Rule><Rule name='ForLoopShouldBeWhileLoop'><Description><![CDATA[A for loop without an init and update statement can be simplified to a while loop.]]></Description></Rule><Rule name='ForStatementBraces'><Description><![CDATA[Use braces for for statements, even for a single statement.]]></Description></Rule><Rule name='GrailsDomainHasEquals'><Description><![CDATA[Checks that Grails domain classes redefine equals().]]></Description></Rule><Rule name='GrailsDomainHasToString'><Description><![CDATA[Checks that Grails domain classes redefine toString()]]></Description></Rule><Rule name='GrailsDomainReservedSqlKeywordName'><Description><![CDATA[Forbids usage of SQL reserved keywords as class or field names in Grails domain classes. Naming a domain class (or its field) with such a keyword causes SQL schema creation errors and/or redundant table/column name mappings.]]></Description></Rule><Rule name='GrailsDomainStringPropertyMaxSize'><Description><![CDATA[String properties in Grails domain classes have to define maximum size otherwise the property is mapped to VARCHAR(255) causing runtime exceptions to occur]]></Description></Rule><Rule name='GrailsDomainWithServiceReference'><Description><![CDATA[Checks that Grails domain classes do not have service classes injected.]]></Description></Rule><Rule name='GrailsDuplicateConstraint'><Description><![CDATA[Check for duplicate entry in domain class constraints]]></Description></Rule><Rule name='GrailsDuplicateMapping'><Description><![CDATA[Check for duplicate name in a domain class mapping]]></Description></Rule><Rule name='GrailsMassAssignment'><Description><![CDATA[Untrusted input should not be allowed to set arbitrary object fields without restriction.]]></Description></Rule><Rule name='GrailsServletContextReference'><Description><![CDATA[Checks for references to the servletContext object from within Grails controller and taglib classes.]]></Description></Rule><Rule name='GrailsStatelessService'><Description><![CDATA[Checks for fields on Grails service classes. Grails service classes are singletons, by default, and so they should be reentrant and typically stateless. The ignoreFieldNames property (dataSource,scope,sessionFactory,transactional,*Service,grailsApplication) specifies one or more field names that should be ignored. The ignoreFieldTypes property (null) specifies one or more field type names that should be ignored. Both can optionally contain wildcard characters ('*' or '?').]]></Description></Rule><Rule name='HardCodedWindowsFileSeparator'><Description><![CDATA[This rule finds usages of a Windows file separator within the constructor call of a File object. It is better to use the Unix file separator or use the File.separator constant.]]></Description></Rule><Rule name='HardCodedWindowsRootDirectory'><Description><![CDATA[This rule find cases where a File object is constructed with a windows-based path. This is not portable, and using the File.listRoots() method is a better alternative.]]></Description></Rule><Rule name='HashtableIsObsolete'><Description><![CDATA[The java.util.Hashtable class is effectively obsolete. Use the Java Collections Framework classes instead, including HashMap or ConcurrentHashMap. See the JDK javadoc.]]></Description></Rule><Rule name='IfStatementBraces'><Description><![CDATA[Use braces for if statements, even for a single statement.]]></Description></Rule><Rule name='IfStatementCouldBeTernary'><Description><![CDATA[Checks for if statements where both the if and else blocks contain only a single return statement with a constant or literal value]]></Description></Rule><Rule name='IllegalClassMember'><Description><![CDATA[Checks for classes containing fields/properties/methods matching configured illegal member modifiers or not matching any of the configured allowed member modifiers.]]></Description></Rule><Rule name='IllegalClassReference'><Description><![CDATA[Checks for reference to any of the classes configured in classNames.]]></Description></Rule><Rule name='IllegalPackageReference'><Description><![CDATA[Checks for reference to any of the packages configured in packageNames.]]></Description></Rule><Rule name='IllegalRegex'><Description><![CDATA[Checks for a specified illegal regular expression within the source code. The regex property specifies the regular expression to check for. It is required and cannot be null or empty.]]></Description></Rule><Rule name='IllegalString'><Description><![CDATA[Checks for a specified illegal string within the source code.]]></Description></Rule><Rule name='IllegalSubclass'><Description><![CDATA[Checks for classes that extend one of the specified set of illegal superclasses configured in superclassNames.]]></Description></Rule><Rule name='ImplementationAsType'><Description><![CDATA[Checks for use of a predefined set of concrete classes (e.g. ArrayList, Hashtable, ConcurrentHashMap) when specifying the type of a method parameter, closure parameter, constructor parameter, method return type or field type. The associated interfaces should be used to specify the type instead.]]></Description></Rule><Rule name='ImportFromSamePackage'><Description><![CDATA[An import of a class that is within the same package is unnecessary.]]></Description></Rule><Rule name='ImportFromSunPackages'><Description><![CDATA[Avoid importing anything from the 'sun.*' packages. These packages are not portable and are likely to change.]]></Description></Rule><Rule name='Indentation'><Description><![CDATA[Check indentation for class and method declarations, and initial statements.]]></Description></Rule><Rule name='Instanceof'><Description><![CDATA[Checks for use of the instanceof operator. Use the ignoreTypeNames property to configure ignored type names.]]></Description></Rule><Rule name='IntegerGetInteger'><Description><![CDATA[This rule catches usages of java.lang.Integer.getInteger(String, ...) which reads an Integer from the System properties. It is often mistakenly used to attempt to read user input or parse a String into an Integer. It is a poor piece of API to use; replace it with System.properties['prop'].]]></Description></Rule><Rule name='InterfaceName'><Description><![CDATA[Verifies that the name of an interface matches a regular expression specified in the regex property. If that property is null or empty, then this rule is not applied (i.e., it does nothing). It defaults to null, so this rule must be explicitly configured to be active.]]></Description></Rule><Rule name='InterfaceNameSameAsSuperInterface'><Description><![CDATA[Checks for any interface that has an identical name to its super-interface, other than the package. This can be very confusing.]]></Description></Rule><Rule name='InvertedCondition'><Description><![CDATA[An inverted condition is one where a constant expression is used on the left hand side of the equals comparision. Such conditions can be confusing especially when used in assertions where the expected value is by convention placed on the right hand side of the comparision.]]></Description></Rule><Rule name='InvertedIfElse'><Description><![CDATA[An inverted if-else statement is one in which there is a single if statement with a single else branch and the boolean test of the if is negated. For instance "if (!x) false else true". It is usually clearer to write this as "if (x) true else false".]]></Description></Rule><Rule name='LineLength'><Description><![CDATA[Checks the maximum length for each line of source code. It checks for number of characters, so lines that include tabs may appear longer than the allowed number when viewing the file. The maximum line length can be configured by setting the length property, which defaults to 120.]]></Description></Rule><Rule name='LocaleSetDefault'><Description><![CDATA[Checks for calls to Locale.setDefault(), which sets the Locale across the entire JVM.]]></Description></Rule><Rule name='LongLiteralWithLowerCaseL'><Description><![CDATA[In Java and Groovy, you can specify long literals with the L or l character, for instance 55L or 24l. It is best practice to always use an uppercase L and never a lowercase l. This is because 11l rendered in some fonts may look like 111 instead of 11L.]]></Description></Rule><Rule name='MethodName'><Description><![CDATA[Verifies that the name of each method matches a regular expression. By default it checks that the method name starts with a lowercase letter. The regex property specifies the regular expression to check the method name against.  The ignoreMethodNames property (null) can specify method names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></Description></Rule><Rule name='MethodParameterTypeRequired'><Description><![CDATA[Checks that method parameters are not dynamically typed, that is they are explicitly stated and different than def.]]></Description></Rule><Rule name='MethodReturnTypeRequired'><Description><![CDATA[Checks that method return types are not dynamic, that is they are explicitly stated and different than def.]]></Description></Rule><Rule name='MisorderedStaticImports'><Description><![CDATA[Static imports should never be declared after nonstatic imports.]]></Description></Rule><Rule name='MissingBlankLineAfterImports'><Description><![CDATA[Makes sure there is a blank line after the imports of a source code file.]]></Description></Rule><Rule name='MissingBlankLineAfterPackage'><Description><![CDATA[Makes sure there is a blank line after the package statement of a source code file.]]></Description></Rule><Rule name='MissingNewInThrowStatement'><Description><![CDATA[A common Groovy mistake when throwing exceptions is to forget the new keyword. For instance, "throw RuntimeException()" instead of "throw new RuntimeException()". If the error path is not unit tested then the production system will throw a Method Missing exception and hide the root cause. This rule finds constructs like "throw RuntimeException()" that look like a new keyword was meant to be used but forgotten.]]></Description></Rule><Rule name='MultipleUnaryOperators'><Description><![CDATA[Checks for multiple consecutive unary operators. These are confusing, and are likely typos and bugs.]]></Description></Rule><Rule name='NestedForLoop'><Description><![CDATA[Reports classes with nested for loops.]]></Description></Rule><Rule name='NoDef'><Description><![CDATA[def should not be used. You should replace it with concrete type.]]></Description></Rule><Rule name='NoJavaUtilDate'><Description><![CDATA[Do not use java.util.Date. Prefer the classes in the java.time.* packages.]]></Description></Rule><Rule name='NoTabCharacter'><Description><![CDATA[Checks that all source files do not contain the tab character]]></Description></Rule><Rule name='NoWildcardImports'><Description><![CDATA[Wildcard imports, static or otherwise, should not be used.]]></Description></Rule><Rule name='ObjectOverrideMisspelledMethodName'><Description><![CDATA[Verifies that the names of the most commonly overridden methods of Object: equals, hashCode and toString, are correct.]]></Description></Rule><Rule name='PackageName'><Description><![CDATA[Verifies that the package name for a class matches a regular expression. By default it checks that the package name consists of only lowercase letters, separated by periods. The regex property specifies the regular expression used to validate the package name. The packageNameRequired property indicates whether a package name declaration is required for all classes.]]></Description></Rule><Rule name='PackageNameMatchesFilePath'><Description><![CDATA[A package source file's path should match the package itself. To find the package-relevant subpath in the file path the groupId needs to be configured. It is expected in every package declaration.]]></Description></Rule><Rule name='ParameterName'><Description><![CDATA[Verifies that the name of each parameter matches a regular expression. This rule applies to method parameters, constructor parameters and closure parameters. By default it checks that parameter names start with a lowercase letter and contains only letters or numbers. The regex property specifies the default regular expression used to validate the parameter name.  The ignoreParameterNames property (null) can specify parameter names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></Description></Rule><Rule name='ParameterReassignment'><Description><![CDATA[Checks for a method or closure parameter being reassigned to a new value within the body of the method/closure, which is a confusing and questionable practice. Use a temporary variable instead.]]></Description></Rule><Rule name='PrivateFieldCouldBeFinal'><Description><![CDATA[Checks for private fields that are only set within a constructor or field initializer. Such fields can safely be made final.]]></Description></Rule><Rule name='PropertyName'><Description><![CDATA[Verifies that the name of each property matches a regular expression. By default it checks that property names other than 'static final' start with a lowercase letter and contains only letters or numbers, and 'static final' property names start with an uppercase letter and contain only uppercase letters, numbers and underscores. The regex property specifies the default regular expression used to validate property names. The finalRegex property specifies the regular expression to validate 'final' property names. The staticRegex property specifies the regular expression to validate 'static' property names. The staticFinalRegex property specifies the regular expression to validate 'static final' property names.  The ignorePropertyNames property (null) can specify property names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></Description></Rule><Rule name='PublicInstanceField'><Description><![CDATA[Using public fields is considered to be a bad design. Use properties instead.]]></Description></Rule><Rule name='PublicMethodsBeforeNonPublicMethods'><Description><![CDATA[Enforce that all public methods are above protected and private methods.]]></Description></Rule><Rule name='RandomDoubleCoercedToZero'><Description><![CDATA[The Math.random() method returns a double result greater than or equal to 0.0 and less than 1.0. If you coerce this result into an Integer or int, then it is coerced to zero. Casting the result to int, or assigning it to an int field is probably a bug.]]></Description></Rule><Rule name='RemoveAllOnSelf'><Description><![CDATA[Don't use removeAll to clear a collection. If you want to remove all elements from a collection c, use c.clear, not c.removeAll(c). Calling c.removeAll(c) to clear a collection is less clear, susceptible to errors from typos, less efficient and for some collections, might throw a ConcurrentModificationException.]]></Description></Rule><Rule name='RequiredRegex'><Description><![CDATA[Checks for a specified regular expression that must exist within the source code. The regex property specifies the regular expression to check for. It is required and cannot be null or empty.]]></Description></Rule><Rule name='RequiredString'><Description><![CDATA[Checks for a specified text string that must exist within the source code. The string property specifies the String to check for. It is required and cannot be null or empty.]]></Description></Rule><Rule name='ReturnFromFinallyBlock'><Description><![CDATA[Returning from a finally block is confusing and can hide the original exception.]]></Description></Rule><Rule name='ReturnNullFromCatchBlock'><Description><![CDATA[Returning null from a catch block often masks errors and requires the client to handle error codes. In some coding styles this is discouraged.]]></Description></Rule><Rule name='ReturnsNullInsteadOfEmptyArray'><Description><![CDATA[Consider returning a zero length array rather than null. It is often a better design to return a length zero array rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.]]></Description></Rule><Rule name='ReturnsNullInsteadOfEmptyCollection'><Description><![CDATA[Consider returning a zero length collection rather than null. It is often a better design to return a length zero collection rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.]]></Description></Rule><Rule name='SimpleDateFormatMissingLocale'><Description><![CDATA[Be sure to specify a Locale when creating a new instance of SimpleDateFormat; the class is locale-sensitive. If you instantiate SimpleDateFormat without a Locale parameter, it will format the date and time according to the default Locale. Both the pattern and the Locale determine the format. For the same pattern, SimpleDateFormat may format a date and time differently if the Locale varies.]]></Description></Rule><Rule name='SpaceAfterCatch'><Description><![CDATA[Check that there is exactly one space (blank) after the catch keyword and before the opening parenthesis.]]></Description></Rule><Rule name='SpaceAfterClosingBrace'><Description><![CDATA[Check that there is at least one space (blank) or whitespace after each closing brace ("}") for method/class/interface declarations, closure expressions and block statements.]]></Description></Rule><Rule name='SpaceAfterComma'><Description><![CDATA[Checks that there is at least one space or whitespace following each comma. That includes checks for method and closure declaration parameter lists, method call parameter lists, Map literals and List literals.]]></Description></Rule><Rule name='SpaceAfterFor'><Description><![CDATA[Check that there is exactly one space (blank) after the for keyword and before the opening parenthesis.]]></Description></Rule><Rule name='SpaceAfterIf'><Description><![CDATA[Check that there is exactly one space (blank) after the if keyword and before the opening parenthesis.]]></Description></Rule><Rule name='SpaceAfterOpeningBrace'><Description><![CDATA[Check that there is at least one space (blank) or whitespace after each opening brace ("{") for method/class/interface declarations, closure expressions and block statements.]]></Description></Rule><Rule name='SpaceAfterSemicolon'><Description><![CDATA[Checks that there is at least one space or whitespace following each semicolon separating multiple statements on a single line or the clauses within a classic for loop.]]></Description></Rule><Rule name='SpaceAfterSwitch'><Description><![CDATA[Check that there is exactly one space (blank) after the switch keyword and before the opening parenthesis.]]></Description></Rule><Rule name='SpaceAfterWhile'><Description><![CDATA[Check that there is exactly one space (blank) after the while keyword and before the opening parenthesis.]]></Description></Rule><Rule name='SpaceAroundClosureArrow'><Description><![CDATA[Checks that there is whitespace around the closure arrow (-&gt;) symbol]]></Description></Rule><Rule name='SpaceAroundMapEntryColon'><Description><![CDATA[Check for configured formatting of whitespace around colons for literal Map entries. The characterBeforeColonRegex and characterAfterColonRegex properties specify a regular expression that must match the character before/after the colon.]]></Description></Rule><Rule name='SpaceAroundOperator'><Description><![CDATA[Check that there is at least one space (blank) or whitespace around each binary operator.]]></Description></Rule><Rule name='SpaceBeforeClosingBrace'><Description><![CDATA[Check that there is at least one space (blank) or whitespace before each closing brace ("}") for method/class/interface declarations, closure expressions and block statements.]]></Description></Rule><Rule name='SpaceBeforeOpeningBrace'><Description><![CDATA[Check that there is at least one space (blank) or whitespace before each opening brace ("{") for method/class/interface declarations, closure expressions and block statements.]]></Description></Rule><Rule name='StatelessClass'><Description><![CDATA[Checks for fields on classes that should remain "stateless" and reentrant. The ignoreFieldNames property (null) specifies one or more field names that should be ignored. The ignoreFieldTypes property specifies one or more field type names that should be ignored. Both can optionally contain wildcard characters ('*' or '?').]]></Description></Rule><Rule name='StatelessSingleton'><Description><![CDATA[There is no point in creating a stateless Singleton because there is nothing within the class that needs guarding and no side effects to calling the constructor. Just create new instances of the object or write a Utility class with static methods.]]></Description></Rule><Rule name='StaticFieldsBeforeInstanceFields'><Description><![CDATA[Enforce that all static fields are above all instance fields within a class]]></Description></Rule><Rule name='StaticMethodsBeforeInstanceMethods'><Description><![CDATA[Enforce that all static methods are above all instance methods within a class]]></Description></Rule><Rule name='SwallowThreadDeath'><Description><![CDATA[Checks for code that catches ThreadDeath without re-throwing it.]]></Description></Rule><Rule name='TernaryCouldBeElvis'><Description><![CDATA[Checks for ternary expressions where the boolean and true expressions are the same. These can be simplified to an Elvis expression.]]></Description></Rule><Rule name='ThrowError'><Description><![CDATA[Checks for throwing an instance of java.lang.Error.]]></Description></Rule><Rule name='ThrowException'><Description><![CDATA[Checks for throwing an instance of java.lang.Exception.]]></Description></Rule><Rule name='ThrowExceptionFromFinallyBlock'><Description><![CDATA[Throwing an exception from a finally block is confusing and can hide the original exception.]]></Description></Rule><Rule name='ThrowNullPointerException'><Description><![CDATA[Checks for throwing an instance of java.lang.NullPointerException.]]></Description></Rule><Rule name='ThrowRuntimeException'><Description><![CDATA[Checks for throwing an instance of java.lang.RuntimeException.]]></Description></Rule><Rule name='ThrowThrowable'><Description><![CDATA[Checks for throwing an instance of java.lang.Throwable.]]></Description></Rule><Rule name='ToStringReturnsNull'><Description><![CDATA[Checks for toString() methods that return null.]]></Description></Rule><Rule name='TrailingComma'><Description><![CDATA[Check whether list and map literals contain optional trailing comma.]]></Description></Rule><Rule name='TrailingWhitespace'><Description><![CDATA[Checks that no lines of source code end with whitespace characters.]]></Description></Rule><Rule name='UnnecessaryBigDecimalInstantiation'><Description><![CDATA[It is unnecessary to instantiate BigDecimal objects. Instead just use the decimal literal or the 'G' identifier to force the type, such as 123.45 or 123.45G.]]></Description></Rule><Rule name='UnnecessaryBigIntegerInstantiation'><Description><![CDATA[It is unnecessary to instantiate BigInteger objects. Instead just use the literal with the 'G' identifier to force the type, such as 8G or 42G.]]></Description></Rule><Rule name='UnnecessaryBooleanExpression'><Description><![CDATA[Checks for unnecessary boolean expressions, including ANDing (&amp;&amp;) or ORing (||) with true, false, null, or a Map/List/String/Number literal. Also checks for negation (!) of true, false, null, or a Map/List/String/Number literal.]]></Description></Rule><Rule name='UnnecessaryBooleanInstantiation'><Description><![CDATA[Use Boolean.valueOf() for variable values or Boolean.TRUE and Boolean.FALSE for constant values instead of calling the Boolean() constructor directly or calling Boolean.valueOf(true) or Boolean.valueOf(false).]]></Description></Rule><Rule name='UnnecessaryCallForLastElement'><Description><![CDATA[This rule checks for excessively verbose methods of accessing the last element of an array or list. For instance, it is possible to access the last element of an array by performing array[array.length - 1], in Groovy it is simpler to either call array.last() or array[-1]. The same is true for lists. This violation is triggered whenever a get, getAt, or array-style access is used with an object size check.]]></Description></Rule><Rule name='UnnecessaryCallToSubstring'><Description><![CDATA[Calling String.substring(0) always returns the original string. This code is meaningless.]]></Description></Rule><Rule name='UnnecessaryCast'><Description><![CDATA[Checks for unnecessary cast operations]]></Description></Rule><Rule name='UnnecessaryCatchBlock'><Description><![CDATA[Violations are triggered when a catch block does nothing but throw the original exception. In this scenario there is usually no need for a catch block, just let the exception be thrown from the original code. This condition frequently occurs when catching an exception for debugging purposes but then forgetting to take the catch statement out.]]></Description></Rule><Rule name='UnnecessaryCollectCall'><Description><![CDATA[Some method calls to Object.collect(Closure) can be replaced with the spread operator. For instance, list.collect { it.multiply(2) } can be replaced by list*.multiply(2). Warning: if a collection is null, collect will return an empty list, while *. will return null.]]></Description></Rule><Rule name='UnnecessaryCollectionCall'><Description><![CDATA[Useless call to collections. This call doesn't make sense. For any collection c, calling c.containsAll(c) should always be true, and c.retainAll(c) should have no effect.]]></Description></Rule><Rule name='UnnecessaryConstructor'><Description><![CDATA[This rule detects when a constructor is not necessary; i.e., when there's only one constructor, it's public, has an empty body, and takes no arguments.]]></Description></Rule><Rule name='UnnecessaryDefInFieldDeclaration'><Description><![CDATA[If a field has a visibility modifier or a type declaration, then the def keyword is unneeded. For instance, 'static def constraints = {}' is redundant and can be simplified to 'static constraints = {}.]]></Description></Rule><Rule name='UnnecessaryDefInMethodDeclaration'><Description><![CDATA[If a method has a visibility modifier or a type declaration, then the def keyword is unneeded. For instance 'def private method() {}' is redundant and can be simplified to 'private method() {}'.]]></Description></Rule><Rule name='UnnecessaryDefInVariableDeclaration'><Description><![CDATA[If a variable has a visibility modifier or a type declaration, then the def keyword is unneeded. For instance 'def private n = 2' is redundant and can be simplified to 'private n = 2'.]]></Description></Rule><Rule name='UnnecessaryDotClass'><Description><![CDATA[To make a reference to a class, it is unnecessary to specify the '.class' identifier. For instance String.class can be shortened to String.]]></Description></Rule><Rule name='UnnecessaryDoubleInstantiation'><Description><![CDATA[It is unnecessary to instantiate Double objects. Instead just use the double literal or the 'D' identifier to force the type, such as 123.45d or 0.42d.]]></Description></Rule><Rule name='UnnecessaryElseStatement'><Description><![CDATA[When an if statement block ends with a return statement the else is unnecessary. The logic in the else branch can be run without being in a new scope.]]></Description></Rule><Rule name='UnnecessaryFinalOnPrivateMethod'><Description><![CDATA[A private method is marked final. Private methods cannot be overridden, so marking it final is unnecessary.]]></Description></Rule><Rule name='UnnecessaryFloatInstantiation'><Description><![CDATA[It is unnecessary to instantiate Float objects. Instead just use the float literal with the 'F' identifier to force the type, such as 123.45F or 0.42f.]]></Description></Rule><Rule name='UnnecessaryGString'><Description><![CDATA[String objects should be created with single quotes, and GString objects created with double quotes. Creating normal String objects with double quotes is confusing to readers.]]></Description></Rule><Rule name='UnnecessaryGetter'><Description><![CDATA[Checks for explicit calls to getter/accessor methods which can, for the most part, be replaced by property access. A getter is defined as a method call that matches get[A-Z] but not getClass() or get[A-Z][A-Z] such as getURL(). Getters do not take method arguments. The ignoreMethodNames property (null) can specify method names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></Description></Rule><Rule name='UnnecessaryGroovyImport'><Description><![CDATA[A Groovy file does not need to include an import for classes from java.lang, java.util, java.io, java.net, groovy.lang and groovy.util, as well as the classes java.math.BigDecimal and java.math.BigInteger.]]></Description></Rule><Rule name='UnnecessaryIfStatement'><Description><![CDATA[Checks for if statements where the if and else blocks (or subsequent fall-through to a return), are merely returning true and false constants. These cases can be replaced by a simple return statement.]]></Description></Rule><Rule name='UnnecessaryInstanceOfCheck'><Description><![CDATA[This rule finds instanceof checks that cannot possibly evaluate to true. For instance, checking that (!variable instanceof String) will never be true because the result of a not expression is always a boolean.]]></Description></Rule><Rule name='UnnecessaryInstantiationToGetClass'><Description><![CDATA[Avoid instantiating an object just to call getClass() on it; use the .class public member instead.]]></Description></Rule><Rule name='UnnecessaryIntegerInstantiation'><Description><![CDATA[It is unnecessary to instantiate Integer objects. Instead just use the literal with the 'I' identifier to force the type, such as 8I or 42i.]]></Description></Rule><Rule name='UnnecessaryLongInstantiation'><Description><![CDATA[It is unnecessary to instantiate Long objects. Instead just use the literal with the 'L' identifier to force the type, such as 8L or 42L.]]></Description></Rule><Rule name='UnnecessaryModOne'><Description><![CDATA[Any expression mod 1 (exp % 1) is guaranteed to always return zero. This code is probably an error, and should be either (exp &amp; 1) or (exp % 2).]]></Description></Rule><Rule name='UnnecessaryNullCheck'><Description><![CDATA[Groovy contains the safe dereference operator, which can be used in boolean conditional statements to safely replace explicit "x == null" tests.]]></Description></Rule><Rule name='UnnecessaryNullCheckBeforeInstanceOf'><Description><![CDATA[There is no need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.]]></Description></Rule><Rule name='UnnecessaryObjectReferences'><Description><![CDATA[Violations are triggered when an excessive set of consecutive statements all reference the same variable. This can be made more readable by using a with or identity block.]]></Description></Rule><Rule name='UnnecessaryOverridingMethod'><Description><![CDATA[The overriding method merely calls the same method defined in a superclass]]></Description></Rule><Rule name='UnnecessaryPackageReference'><Description><![CDATA[Checks for explicit package reference for classes that Groovy imports by default, such as java.lang.String, java.util.Map and groovy.lang.Closure.]]></Description></Rule><Rule name='UnnecessaryParenthesesForMethodCallWithClosure'><Description><![CDATA[If a method is called and the only parameter to that method is an inline closure then the parentheses of the method call can be omitted.]]></Description></Rule><Rule name='UnnecessaryPublicModifier'><Description><![CDATA[The 'public' modifier is not required on methods or classes.]]></Description></Rule><Rule name='UnnecessaryReturnKeyword'><Description><![CDATA[In Groovy, the return keyword is often optional. If a statement is the last line in a method or closure then you do not need to have the return keyword.]]></Description></Rule><Rule name='UnnecessarySafeNavigationOperator'><Description><![CDATA[Check for the safe navigation operator (?.) applied to constants and literals, which can never be null.]]></Description></Rule><Rule name='UnnecessarySelfAssignment'><Description><![CDATA[Method contains a pointless self-assignment to a variable or property.]]></Description></Rule><Rule name='UnnecessarySemicolon'><Description><![CDATA[Semicolons as line terminators are not required in Groovy: remove them. Do not use a semicolon as a replacement for empty braces on for and while loops; this is a confusing practice.]]></Description></Rule><Rule name='UnnecessarySetter'><Description><![CDATA[Checks for explicit calls to setter methods which can, for the most part, be replaced by assignment to property. A setter is defined as a method call that matches set[A-Z] but not set[A-Z][A-Z] such as setURL(). Setters take one method argument.]]></Description></Rule><Rule name='UnnecessaryStringInstantiation'><Description><![CDATA[Use a String literal (e.g., "...") instead of calling the corresponding String constructor (new String("..")) directly.]]></Description></Rule><Rule name='UnnecessarySubstring'><Description><![CDATA[This rule finds usages of String.substring(int) and String.substring(int, int) that can be replaced by use of the subscript operator. For instance, var.substring(5) can be replaced with var[5..-1].]]></Description></Rule><Rule name='UnnecessaryTernaryExpression'><Description><![CDATA[Checks for ternary expressions where the conditional expression always evaluates to a boolean and the true and false expressions are merely returning true and false constants. Also checks for ternary expressions where both expressions are the same constant or variable.]]></Description></Rule><Rule name='UnnecessaryToString'><Description><![CDATA[Checks for unnecessary calls to toString().]]></Description></Rule><Rule name='UnnecessaryTransientModifier'><Description><![CDATA[The field is marked as transient, but the class isn't Serializable, so marking it as transient has no effect.]]></Description></Rule><Rule name='UnusedArray'><Description><![CDATA[Checks for array allocations that are not assigned or used, unless it is the last statement within a block.]]></Description></Rule><Rule name='UnusedImport'><Description><![CDATA[Imports for a class that is never referenced within the source file is unnecessary.]]></Description></Rule><Rule name='UnusedMethodParameter'><Description><![CDATA[This rule finds instances of method parameters not being used. It does not analyze private methods (that is done by the UnusedPrivateMethodParameter rule) or methods marked @Override.]]></Description></Rule><Rule name='UnusedObject'><Description><![CDATA[Checks for object allocations that are not assigned or used, unless it is the last statement within a block.]]></Description></Rule><Rule name='UnusedPrivateField'><Description><![CDATA[Checks for private fields that are not referenced within the same class.]]></Description></Rule><Rule name='UnusedPrivateMethod'><Description><![CDATA[Checks for private methods that are not referenced within the same class.]]></Description></Rule><Rule name='UnusedPrivateMethodParameter'><Description><![CDATA[Checks for parameters to private methods that are not referenced within the method body.]]></Description></Rule><Rule name='UnusedVariable'><Description><![CDATA[Checks for variables that are never referenced. The ignoreVariableNames property (null) specifies one or more variable names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></Description></Rule><Rule name='VariableName'><Description><![CDATA[Verifies that the name of each method matches a regular expression. By default it checks that non-'final' variable names start with a lowercase letter and contains only letters or numbers, and 'final' variable names start with an uppercase letter and contain only uppercase letters, numbers and underscores. The regex property specifies the default regular expression used to validate a non-'final' variable name. The finalRegex property specifies the regular expression used to validate 'final' variable names. The ignoreVariableNames property (null) can specify variable names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></Description></Rule><Rule name='VariableTypeRequired'><Description><![CDATA[Checks that variable types are explicitly specified in declarations (and not using def)]]></Description></Rule><Rule name='VectorIsObsolete'><Description><![CDATA[The java.util.Vector class is effectively obsolete. Use the Java Collections Framework classes instead, including ArrayList or Collections.synchronizedList(). See the JDK javadoc.]]></Description></Rule><Rule name='WhileStatementBraces'><Description><![CDATA[Use braces for while statements, even for a single statement.]]></Description></Rule></Rules></CodeNarc>